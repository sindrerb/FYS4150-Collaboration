// Initialize the seed and call the Mersienne algo
    std::random_device rd;
    std::mt19937_64 gen(rd());
    // Set up the uniform distribution for x \in [[0, 1]
    std::uniform_real_distribution<double> randomGenerator(0.0,1.0);
    // Set up array for possible energy transitions
    w = new double[17];
    for( int de =-8; de <= 8; de++) w[de+8] = 0;
    for( int de =-8; de <= 8; de+=4) w[de+8] = exp(-de/temperature);

    // Initialize storage variables
    expectationValues = new double[6];
    for( int i=0; i<6; i++) expectationValues[i]=0;

    // Equilibrium
    double acceptedChanges = 0;
    // Do Monte Carlo calculations
    for (int cycles = start; cycles <= end; cycles++){
      for(int x =1; x < nSpin+1; x++) {
        for (int y= 1; y < nSpin+1; y++){

          // Chose a random spin to flip
          int ix = (int) (randomGenerator(gen)*(double)nSpin)+1;
          int iy = (int) (randomGenerator(gen)*(double)nSpin)+1;

          // Calculate the energy difference of flipping the chosen spin
          int deltaE =  2*(*pseudoLattice[ix][iy])*((*pseudoLattice[ix+1][iy])+(*pseudoLattice[ix-1][iy])+(*pseudoLattice[ix][iy+1])+(*pseudoLattice[ix][iy-1]));
          // Perform the Metropolis criteria
          if ( randomGenerator(gen) <= w[deltaE+8] ) {
            // Flip the spin
            lattice[ix-1][iy-1] *= -1.0;
            // Save new properties
            magneticMoment += (double) 2*(*pseudoLattice[ix][iy]);
            energy += (double) deltaE;

           // Log the number of accepted changes
            acceptedChanges += 1;
          }
        }
      }

      // Update expectation values  for local node
      expectationValues[0] += energy;
      expectationValues[1] += energy*energy;
      expectationValues[2] += magneticMoment;
      expectationValues[3] += magneticMoment*magneticMoment;
      expectationValues[4] += fabs(magneticMoment);
    }
    expectationValues[5] += acceptedChanges;
    return expectationValues;
